//
// @project GeniusRabbit
// @author Dmitry Ponomarev <demdxx@gmail.com> 2016 â€“ 2017
//
// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package gosql

import (
	"bytes"
	"strconv"
	"strings"
)

// IntArrayDecode decodes array of type int
func IntArrayDecode(data interface{}) (result []int, err error) {
	var (
		arr string
		t   int
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []int:
		return data.([]int), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]int, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, int(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, int(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, int(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// IntArrayEncode encodes array of type int
func IntArrayEncode(begin, end byte, arr []int) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Int8ArrayDecode decodes array of type int8
func Int8ArrayDecode(data interface{}) (result []int8, err error) {
	var (
		arr string
		t   int8
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []int8:
		return data.([]int8), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]int8, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, int8(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, int8(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, int8(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Int8ArrayEncode encodes array of type int8
func Int8ArrayEncode(begin, end byte, arr []int8) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Int16ArrayDecode decodes array of type int16
func Int16ArrayDecode(data interface{}) (result []int16, err error) {
	var (
		arr string
		t   int16
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []int16:
		return data.([]int16), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]int16, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, int16(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, int16(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, int16(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Int16ArrayEncode encodes array of type int16
func Int16ArrayEncode(begin, end byte, arr []int16) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Int32ArrayDecode decodes array of type int32
func Int32ArrayDecode(data interface{}) (result []int32, err error) {
	var (
		arr string
		t   int32
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []int32:
		return data.([]int32), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]int32, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, int32(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, int32(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, int32(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Int32ArrayEncode encodes array of type int32
func Int32ArrayEncode(begin, end byte, arr []int32) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Int64ArrayDecode decodes array of type int64
func Int64ArrayDecode(data interface{}) (result []int64, err error) {
	var (
		arr string
		t   int64
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []int64:
		return data.([]int64), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]int64, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, int64(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, int64(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, int64(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Int64ArrayEncode encodes array of type int64
func Int64ArrayEncode(begin, end byte, arr []int64) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// UintArrayDecode decodes array of type uint
func UintArrayDecode(data interface{}) (result []uint, err error) {
	var (
		arr string
		t   uint
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []uint:
		return data.([]uint), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]uint, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, uint(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, uint(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, uint(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// UintArrayEncode encodes array of type uint
func UintArrayEncode(begin, end byte, arr []uint) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Uint8ArrayDecode decodes array of type uint8
func Uint8ArrayDecode(data interface{}) (result []uint8, err error) {
	var (
		arr string
		t   uint8
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []uint8:
		return data.([]uint8), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]uint8, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, uint8(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, uint8(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, uint8(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Uint8ArrayEncode encodes array of type uint8
func Uint8ArrayEncode(begin, end byte, arr []uint8) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Uint16ArrayDecode decodes array of type uint16
func Uint16ArrayDecode(data interface{}) (result []uint16, err error) {
	var (
		arr string
		t   uint16
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []uint16:
		return data.([]uint16), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]uint16, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, uint16(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, uint16(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, uint16(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Uint16ArrayEncode encodes array of type uint16
func Uint16ArrayEncode(begin, end byte, arr []uint16) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Uint32ArrayDecode decodes array of type uint32
func Uint32ArrayDecode(data interface{}) (result []uint32, err error) {
	var (
		arr string
		t   uint32
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []uint32:
		return data.([]uint32), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]uint32, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, uint32(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, uint32(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, uint32(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Uint32ArrayEncode encodes array of type uint32
func Uint32ArrayEncode(begin, end byte, arr []uint32) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Uint64ArrayDecode decodes array of type uint64
func Uint64ArrayDecode(data interface{}) (result []uint64, err error) {
	var (
		arr string
		t   uint64
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []uint64:
		return data.([]uint64), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]uint64, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, uint64(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, uint64(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, uint64(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Uint64ArrayEncode encodes array of type uint64
func Uint64ArrayEncode(begin, end byte, arr []uint64) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Float32ArrayDecode decodes array of type float32
func Float32ArrayDecode(data interface{}) (result []float32, err error) {
	var (
		arr string
		t   float32
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []float32:
		return data.([]float32), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]float32, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, float32(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, float32(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, float32(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Float32ArrayEncode encodes array of type float32
func Float32ArrayEncode(begin, end byte, arr []float32) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}

// Float64ArrayDecode decodes array of type float64
func Float64ArrayDecode(data interface{}) (result []float64, err error) {
	var (
		arr string
		t   float64
	)
	switch data.(type) {
	case []byte:
		arr = string(data.([]byte))
	case string:
		arr = data.(string)
	case []float64:
		return data.([]float64), nil
	case nil:
		return nil, nil
	default:
		return nil, ErrInvalidScan
	}

	if "null" == arr || "NULL" == arr {
		return nil, nil
	}

	result = make([]float64, 0)
	if arr != "{}" && arr != "[]" && len(arr) > 0 {
		if vals := strings.Split(strings.Trim(arr, "{}[]"), ","); vals != nil {
			for _, cid := range vals {
				var br = false

				switch interface{}(t).(type) {
				case int, int8, int16, int32, int64:
					var v int64
					if v, err = strconv.ParseInt(strings.Trim(cid, "'\""), 10, 64); err == nil {
						result = append(result, float64(v))
					} else {
						br = true
					}
				case uint, uint8, uint16, uint32, uint64:
					var v uint64
					if v, err = strconv.ParseUint(strings.Trim(cid, "'\""), 10, 64); nil == err {
						result = append(result, float64(v))
					} else {
						br = true
					}
				case float32, float64:
					var v float64
					if v, err = strconv.ParseFloat(strings.Trim(cid, "'\""), 64); nil == err {
						result = append(result, float64(v))
					} else {
						br = true
					}
				}

				if br {
					break
				}

			} // end for
		}
	}
	return
}

// Float64ArrayEncode encodes array of type float64
func Float64ArrayEncode(begin, end byte, arr []float64) *bytes.Buffer {
	var buff bytes.Buffer
	buff.WriteByte(begin)

	if nil != arr {
		for i, v := range arr {
			if i > 0 {
				buff.WriteByte(',')
			}

			switch interface{}(v).(type) {
			case int, int8, int16, int32, int64:
				buff.WriteString(strconv.Itoa(int(v)))
			case uint, uint8, uint16, uint32, uint64:
				buff.WriteString(strconv.FormatUint(uint64(v), 10))
			case float32, float64:
				buff.WriteString(strconv.FormatFloat(float64(v), 'G', -1, 64))
			}

		}
	}

	buff.WriteByte(end)
	return &buff
}
